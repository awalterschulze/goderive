The deriveCompose function composes multiple functions that return an error into one function.

Given the following input:

```go
package compose

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

func upgradeUser(endpoint, username string) error {
	getEndpoint := fmt.Sprintf("%s/oldusers/%s", endpoint, username)
	postEndpoint := fmt.Sprintf("%s/newusers/%s", endpoint, username)

	_, err := deriveCompose(
		http.Get,
		func(req *http.Response) ([]byte, error) {
			return ioutil.ReadAll(req.Body)
		},
		newUserFromJson,
		newUserFromUser,
		json.Marshal,
		func(buf []byte) (*http.Response, error) {
			return http.Post(
				postEndpoint,
				"application/json",
				bytes.NewBuffer(buf),
			)
		},
	)(getEndpoint)
	return err
}

type user struct {
	Name string
}

func newUserFromJson(buf []byte) (*user, error) {
	u := &user{}
	return u, json.Unmarshal(buf, u)
}

type newUser struct {
	Name      string
	LastNames string
}

func newUserFromUser(u *user) (*newUser, error) {
	names := strings.Split(u.Name, " ")
	n := &newUser{Name: names[0]}
	if len(names) <= 1 {
		return nil, fmt.Errorf("user has no last name")
	}
	n.LastNames = strings.Join(names[1:], " ")
	return n, nil
}
```

goderive will generate the following code:

```go
// Code generated by goderive DO NOT EDIT.

package compose

import (
	http "net/http"
)

func deriveCompose(f0 func(string) (*http.Response, error), f1 func(*http.Response) ([]byte, error), f2 func([]byte) (*user, error), f3 func(*user) (*newUser, error), f4 func(interface{}) ([]byte, error), f5 func([]byte) (*http.Response, error)) func(string) (*http.Response, error) {
	return func(v_0_0 string) (*http.Response, error) {
		v_1_0, err0 := f0(v_0_0)
		if err0 != nil {
			return nil, err0
		}
		v_2_0, err1 := f1(v_1_0)
		if err1 != nil {
			return nil, err1
		}
		v_3_0, err2 := f2(v_2_0)
		if err2 != nil {
			return nil, err2
		}
		v_4_0, err3 := f3(v_3_0)
		if err3 != nil {
			return nil, err3
		}
		v_5_0, err4 := f4(v_4_0)
		if err4 != nil {
			return nil, err4
		}
		v_6_0, err5 := f5(v_5_0)
		if err5 != nil {
			return nil, err5
		}
		return v_6_0, nil
	}
}
```