// Code generated by goderive DO NOT EDIT.

package main

// deriveMem returns a memoized version of the input function.
func deriveMem(f func(firstname string, age *int) *string) func(firstname string, age *int) *string {
	type input struct {
		Param0 string
		Param1 *int
	}
	type mem struct {
		in  input
		out *string
	}
	m := make(map[uint64][]mem)
	return func(param0 string, param1 *int) *string {
		in := input{param0, param1}
		h := deriveHash(in)
		vs, ok := m[h]
		if ok {
			for _, v := range vs {
				if deriveEqual(v.in, in) {
					return v.out
				}
			}
		}
		res0 := f(param0, param1)
		m[h] = append(m[h], mem{in, res0})
		return res0
	}
}

// deriveEqual returns whether this and that are equal.
func deriveEqual(this, that struct {
	Param0 string
	Param1 *int
}) bool {
	return this.Param0 == that.Param0 &&
		((this.Param1 == nil && that.Param1 == nil) || (this.Param1 != nil && that.Param1 != nil && *(this.Param1) == *(that.Param1)))
}

// deriveHash returns the hash of the object.
func deriveHash(object struct {
	Param0 string
	Param1 *int
}) uint64 {
	h := uint64(17)
	h = 31*h + deriveHash_(object.Param0)
	h = 31*h + deriveHash_1(object.Param1)
	return h
}

// deriveHash_ returns the hash of the object.
func deriveHash_(object string) uint64 {
	var h uint64
	for _, c := range object {
		h = 31*h + uint64(c)
	}
	return h
}

// deriveHash_1 returns the hash of the object.
func deriveHash_1(object *int) uint64 {
	if object == nil {
		return 0
	}
	return (31 * 17) + uint64(*object)
}
